{"version":3,"sources":["../../src/decorator/string/Matches.ts"],"names":[],"mappings":";;AACA,4CAAuD;AACvD,0DAA6D;AAEhD,QAAA,OAAO,GAAG,SAAS,CAAC;AAEjC;;;GAGG;AACH,iBAAwB,KAAa,EAAE,OAAe,EAAE,SAAkB;IACtE,OAAO,OAAO,KAAK,KAAK,QAAQ,IAAI,kBAAkB,CAAC,KAAK,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;AACtF,CAAC;AAFD,0BAEC;AAOD,iBAAwB,OAAe,EAAE,4BAAyD,EAAE,iBAAqC;IACrI,IAAI,SAAiB,CAAC;IACtB,IAAI,4BAA4B,IAAI,4BAA4B,YAAY,MAAM,IAAI,CAAC,iBAAiB,EAAE;QACtG,iBAAiB,GAAG,4BAAiD,CAAC;KACzE;SAAM;QACH,SAAS,GAAG,4BAAsC,CAAC;KACtD;IACD,OAAO,uBAAU,CAAC;QACV,IAAI,EAAE,eAAO;QACb,QAAQ,EAAE,UAAC,KAAK,EAAE,IAAI,IAAK,OAAA,OAAO,CAAC,KAAK,EAAE,IAAI,CAAC,WAAW,CAAC,CAAC,CAAC,CAAC,EAAnC,CAAmC;QAC9D,WAAW,EAAE,CAAC,OAAO,EAAE,SAAS,CAAC;QACjC,cAAc,EAAE,yBAAY,CAAC,UAAC,UAAU,IAAK,OAAA,UAAU,GAAG,sDAAsD,EAAnE,CAAmE,EAAE,iBAAiB,CAAC;KACvI,EACD,iBAAiB,CACpB,CAAC;AACN,CAAC;AAfD,0BAeC","file":"Matches.js","sourcesContent":["import {ValidationOptions} from \"../ValidationOptions\";\nimport {buildMessage, ValidateBy} from \"../ValidateBy\";\nimport validatorJsMatches = require(\"validator/lib/matches\");\n\nexport const MATCHES = \"matches\";\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i) or matches('foo', 'foo', 'i').\n * If given value is not a string, then it returns false.\n */\nexport function matches(value: string, pattern: RegExp, modifiers?: string): boolean {\n    return typeof value === \"string\" && validatorJsMatches(value, pattern, modifiers);\n}\n\n/**\n * Checks if string matches the pattern. Either matches('foo', /foo/i) or matches('foo', 'foo', 'i').\n */\nexport function Matches(pattern: RegExp, validationOptions?: ValidationOptions): Function;\nexport function Matches(pattern: RegExp, modifiers?: string, validationOptions?: ValidationOptions): Function;\nexport function Matches(pattern: RegExp, modifiersOrAnnotationOptions?: string | ValidationOptions, validationOptions?: ValidationOptions): Function {\n    let modifiers: string;\n    if (modifiersOrAnnotationOptions && modifiersOrAnnotationOptions instanceof Object && !validationOptions) {\n        validationOptions = modifiersOrAnnotationOptions as ValidationOptions;\n    } else {\n        modifiers = modifiersOrAnnotationOptions as string;\n    }\n    return ValidateBy({\n            name: MATCHES,\n            validate: (value, args) => matches(value, args.constraints[0]),\n            constraints: [pattern, modifiers],\n            defaultMessage: buildMessage((eachPrefix) => eachPrefix + \"$property must match $constraint1 regular expression\", validationOptions)\n        },\n        validationOptions\n    );\n}\n"],"sourceRoot":"../.."}