{"version":3,"sources":["../../src/validation/ValidationExecutor.ts"],"names":[],"mappings":"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","file":"ValidationExecutor.js","sourcesContent":["import { Validator } from \"./Validator\";\nimport { ValidationError } from \"./ValidationError\";\nimport { ValidationMetadata } from \"../metadata/ValidationMetadata\";\nimport { MetadataStorage } from \"../metadata/MetadataStorage\";\nimport { getFromContainer } from \"../container\";\nimport { ValidatorOptions } from \"./ValidatorOptions\";\nimport { ValidationTypes } from \"./ValidationTypes\";\nimport { ConstraintMetadata } from \"../metadata/ConstraintMetadata\";\nimport { ValidationArguments } from \"./ValidationArguments\";\nimport { ValidationUtils } from \"./ValidationUtils\";\n\n/**\n * Executes validation over given object.\n */\nexport class ValidationExecutor {\n    // -------------------------------------------------------------------------\n    // Properties\n    // -------------------------------------------------------------------------\n\n    awaitingPromises: Promise<any>[] = [];\n    ignoreAsyncValidations: boolean = false;\n\n    // -------------------------------------------------------------------------\n    // Private Properties\n    // -------------------------------------------------------------------------\n\n    private metadataStorage = getFromContainer(MetadataStorage);\n\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n\n    constructor(\n        private validator: Validator,\n        private validatorOptions?: ValidatorOptions\n    ) {}\n\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n\n    execute(\n        object: Object,\n        targetSchema: string,\n        validationErrors: ValidationError[]\n    ) {\n        /**\n         * If there is no metadata registered it means possibly the dependencies are not flatterned and\n         * more than one instance is used.\n         *\n         * TODO: This needs proper handling, forcing to use the same container or some other proper solution.\n         */\n        if (!this.metadataStorage.hasValidationMetaData) {\n            console.warn(\n                `No metadata found. There is more than once class-validator version installed probably. You need to flatten your dependencies.`\n            );\n        }\n\n        const groups = this.validatorOptions\n            ? this.validatorOptions.groups\n            : undefined;\n        const targetMetadatas = this.metadataStorage.getTargetValidationMetadatas(\n            object.constructor,\n            targetSchema,\n            groups\n        );\n        const groupedMetadatas = this.metadataStorage.groupByPropertyName(\n            targetMetadatas\n        );\n\n        if (\n            this.validatorOptions &&\n            this.validatorOptions.forbidUnknownValues &&\n            !targetMetadatas.length\n        ) {\n            const validationError = new ValidationError();\n\n            if (\n                !this.validatorOptions ||\n                !this.validatorOptions.validationError ||\n                this.validatorOptions.validationError.target === undefined ||\n                this.validatorOptions.validationError.target === true\n            ) {\n                validationError.target = object;\n            }\n\n            validationError.value = undefined;\n            validationError.property = undefined;\n            validationError.children = [];\n            validationError.constraints = {\n                unknownValue:\n                    \"an unknown value was passed to the validate function\"\n            };\n\n            validationErrors.push(validationError);\n\n            return;\n        }\n\n        if (this.validatorOptions && this.validatorOptions.whitelist) {\n            this.whitelist(object, groupedMetadatas, validationErrors);\n        }\n\n        const PREDEFINED_VALIDATION_TYPES = [\n            ValidationTypes.NESTED_VALIDATION,\n            ValidationTypes.CONDITIONAL_VALIDATION,\n            ValidationTypes.WHITELIST,\n            ValidationTypes.IS_DEFINED\n        ];\n\n        // General validation\n        Object.keys(groupedMetadatas).forEach(propertyName => {\n            const value = (object as any)[propertyName];\n            const definedMetadatas = groupedMetadatas[propertyName].filter(\n                metadata => metadata.type === ValidationTypes.IS_DEFINED\n            );\n            const metadatas = groupedMetadatas[propertyName].filter(\n                metadata =>\n                    metadata.type !== ValidationTypes.IS_DEFINED &&\n                    metadata.type !== ValidationTypes.WHITELIST\n            );\n            const customValidationMetadatas = metadatas.filter(\n                metadata =>\n                    PREDEFINED_VALIDATION_TYPES.indexOf(metadata.type) === -1\n            );\n            const nestedValidationMetadatas = metadatas.filter(\n                metadata => metadata.type === ValidationTypes.NESTED_VALIDATION\n            );\n            const conditionalValidationMetadatas = metadatas.filter(\n                metadata =>\n                    metadata.type === ValidationTypes.CONDITIONAL_VALIDATION\n            );\n\n            const validationError = this.generateValidationError(\n                object,\n                value,\n                propertyName\n            );\n            validationErrors.push(validationError);\n\n            const canValidate = this.conditionalValidations(\n                object,\n                value,\n                conditionalValidationMetadatas\n            );\n            if (!canValidate) {\n                return;\n            }\n\n            // handle IS_DEFINED validation type the special way - it should work no matter skipMissingProperties is set or not\n            this.runValidations(\n                object,\n                value,\n                definedMetadatas,\n                validationError.constraints\n            );\n\n            if (\n                (value === null || value === undefined) &&\n                this.validatorOptions &&\n                this.validatorOptions.skipMissingProperties === true\n            ) {\n                return;\n            }\n\n            this.runValidations(\n                object,\n                value,\n                customValidationMetadatas,\n                validationError.constraints\n            );\n            this.nestedValidations(\n                value,\n                nestedValidationMetadatas,\n                validationError.children\n            );\n\n            this.mapContexts(object, value, metadatas, validationError);\n        });\n    }\n\n    whitelist(\n        object: any,\n        groupedMetadatas: { [propertyName: string]: ValidationMetadata[] },\n        validationErrors: ValidationError[]\n    ) {\n        let notAllowedProperties: string[] = [];\n\n        Object.keys(object).forEach(propertyName => {\n            // does this property have no metadata?\n            if (\n                !groupedMetadatas[propertyName] ||\n                groupedMetadatas[propertyName].length === 0\n            )\n                notAllowedProperties.push(propertyName);\n        });\n\n        if (notAllowedProperties.length > 0) {\n            if (\n                this.validatorOptions &&\n                this.validatorOptions.forbidNonWhitelisted\n            ) {\n                // throw errors\n                notAllowedProperties.forEach(property => {\n                    validationErrors.push({\n                        target: object,\n                        property,\n                        value: (object as any)[property],\n                        children: undefined,\n                        constraints: {\n                            [ValidationTypes.WHITELIST]: `property ${property} should not exist`\n                        }\n                    });\n                });\n            } else {\n                // strip non allowed properties\n                notAllowedProperties.forEach(\n                    property => delete (object as any)[property]\n                );\n            }\n        }\n    }\n\n    stripEmptyErrors(errors: ValidationError[]) {\n        return errors.filter(error => {\n            if (error.children) {\n                error.children = this.stripEmptyErrors(error.children);\n            }\n\n            if (Object.keys(error.constraints).length === 0) {\n                if (error.children.length === 0) {\n                    return false;\n                } else {\n                    delete error.constraints;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n\n    private generateValidationError(\n        object: Object,\n        value: any,\n        propertyName: string\n    ) {\n        const validationError = new ValidationError();\n\n        if (\n            !this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.target === undefined ||\n            this.validatorOptions.validationError.target === true\n        )\n            validationError.target = object;\n\n        if (\n            !this.validatorOptions ||\n            !this.validatorOptions.validationError ||\n            this.validatorOptions.validationError.value === undefined ||\n            this.validatorOptions.validationError.value === true\n        )\n            validationError.value = value;\n\n        validationError.property = propertyName;\n        validationError.children = [];\n        validationError.constraints = {};\n\n        return validationError;\n    }\n\n    private conditionalValidations(\n        object: Object,\n        value: any,\n        metadatas: ValidationMetadata[]\n    ) {\n        return metadatas\n            .map(metadata => metadata.constraints[0](object, value))\n            .reduce((resultA, resultB) => resultA && resultB, true);\n    }\n\n    private runValidations(\n        object: Object,\n        value: any,\n        metadatas: ValidationMetadata[],\n        errorMap: { [key: string]: string }\n    ) {\n        metadatas.forEach(metadata => {\n            getFromContainer(MetadataStorage)\n                .getTargetValidatorConstraints(metadata.constraintCls)\n                .forEach(customConstraintMetadata => {\n                    if (\n                        customConstraintMetadata.async &&\n                        this.ignoreAsyncValidations\n                    ) {\n                        return;\n                    }\n\n                    const validateValues =\n                        metadata.each && value instanceof Array\n                            ? [].concat(value)\n                            : [value];\n\n                    validateValues.forEach(value => {\n                        const validationArguments: ValidationArguments = {\n                            targetName: object.constructor\n                                ? (object.constructor as any).name\n                                : undefined,\n                            property: metadata.propertyName,\n                            object: object,\n                            value: value,\n                            constraints: metadata.constraints\n                        };\n\n                        const validatedValue = customConstraintMetadata.instance.validate(\n                            value,\n                            validationArguments\n                        );\n\n                        if (validatedValue instanceof Promise) {\n                            const promise = validatedValue.then(isValid => {\n                                if (!isValid) {\n                                    const [\n                                        type,\n                                        message\n                                    ] = this.createValidationError(\n                                        object,\n                                        value,\n                                        metadata,\n                                        customConstraintMetadata\n                                    );\n                                    errorMap[type] = message;\n                                }\n                            });\n\n                            this.awaitingPromises.push(promise);\n                        } else {\n                            if (!validatedValue) {\n                                const [\n                                    type,\n                                    message\n                                ] = this.createValidationError(\n                                    object,\n                                    value,\n                                    metadata,\n                                    customConstraintMetadata\n                                );\n                                errorMap[type] = message;\n                            }\n                        }\n                    });\n                });\n        });\n    }\n\n    private nestedValidations(\n        value: any,\n        metadatas: ValidationMetadata[],\n        errors: ValidationError[]\n    ) {\n        if (value === void 0) {\n            return;\n        }\n\n        metadatas.forEach(metadata => {\n            if (metadata.type !== ValidationTypes.NESTED_VALIDATION) {\n                return;\n            }\n            const targetSchema =\n                typeof metadata.target === \"string\"\n                    ? (metadata.target as string)\n                    : undefined;\n\n            if (value instanceof Array) {\n                value.forEach((subValue: any, index: number) => {\n                    const validationError = this.generateValidationError(\n                        value,\n                        subValue,\n                        index.toString()\n                    );\n                    errors.push(validationError);\n\n                    this.execute(\n                        subValue,\n                        targetSchema,\n                        validationError.children\n                    );\n                });\n            } else if (value instanceof Object) {\n                this.execute(value, targetSchema, errors);\n            } else {\n                const error = new ValidationError();\n                error.value = value;\n                error.property = metadata.propertyName;\n                error.target = metadata.target;\n                const [type, message] = this.createValidationError(\n                    metadata.target,\n                    value,\n                    metadata\n                );\n                error.constraints = {\n                    [type]: message\n                };\n                errors.push(error);\n            }\n        });\n    }\n\n    private mapContexts(\n        object: Object,\n        value: any,\n        metadatas: ValidationMetadata[],\n        error: ValidationError\n    ) {\n        return metadatas.forEach(metadata => {\n            if (metadata.context) {\n                const type = this.getConstraintType(metadata);\n\n                if (error.constraints[type]) {\n                    if (!error.contexts) {\n                        error.contexts = {};\n                    }\n\n                    error.contexts[type] = Object.assign(\n                        error.contexts[type] || {},\n                        metadata.context\n                    );\n                }\n            }\n        });\n    }\n\n    private createValidationError(\n        object: Object,\n        value: any,\n        metadata: ValidationMetadata,\n        customValidatorMetadata?: ConstraintMetadata\n    ): [string, string] {\n        const targetName = object.constructor\n            ? (object.constructor as any).name\n            : undefined;\n        const type = this.getConstraintType(metadata, customValidatorMetadata);\n        const validationArguments: ValidationArguments = {\n            targetName: targetName,\n            property: metadata.propertyName,\n            object: object,\n            value: value,\n            constraints: metadata.constraints\n        };\n\n        let message = metadata.message;\n        if (\n            !metadata.message &&\n            (!this.validatorOptions ||\n                (this.validatorOptions &&\n                    !this.validatorOptions.dismissDefaultMessages))\n        ) {\n            if (\n                customValidatorMetadata &&\n                customValidatorMetadata.instance.defaultMessage instanceof\n                    Function\n            ) {\n                message = customValidatorMetadata.instance.defaultMessage(\n                    validationArguments\n                );\n            }\n\n            message = message || \"\";\n        }\n\n        const messageString = ValidationUtils.replaceMessageSpecialTokens(\n            message,\n            validationArguments\n        );\n        return [type, messageString];\n    }\n\n    private getConstraintType(\n        metadata: ValidationMetadata,\n        customValidatorMetadata?: ConstraintMetadata\n    ): string {\n        const type =\n            customValidatorMetadata && customValidatorMetadata.name\n                ? customValidatorMetadata.name\n                : metadata.type;\n        return type;\n    }\n}\n"],"sourceRoot":".."}